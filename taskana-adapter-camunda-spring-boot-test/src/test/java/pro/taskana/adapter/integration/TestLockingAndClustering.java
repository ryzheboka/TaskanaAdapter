package pro.taskana.adapter.integration;

import static org.assertj.core.api.Assertions.assertThat;

import java.security.PrivilegedAction;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.security.auth.Subject;
import org.json.JSONObject;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import pro.taskana.adapter.camunda.outbox.rest.resource.CamundaTaskEventListResource;
import pro.taskana.adapter.impl.ReferencedTaskClaimCanceler;
import pro.taskana.adapter.impl.ReferencedTaskClaimer;
import pro.taskana.adapter.impl.ReferencedTaskCompleter;
import pro.taskana.adapter.impl.TaskanaTaskStarter;
import pro.taskana.adapter.impl.TaskanaTaskTerminator;
import pro.taskana.adapter.systemconnector.camunda.api.impl.HttpHeaderProvider;
import pro.taskana.adapter.test.TaskanaAdapterTestApplication;
import pro.taskana.common.api.security.UserPrincipal;
import pro.taskana.common.test.security.JaasExtension;
import pro.taskana.common.test.security.WithAccessId;
import pro.taskana.common.test.util.ParallelThreadHelper;
import pro.taskana.task.api.models.TaskSummary;


/**
 * Test class to test the conversion of tasks generated by Camunda BPM to Taskana tasks.
 */
@SpringBootTest(
    classes = TaskanaAdapterTestApplication.class,
    webEnvironment = WebEnvironment.DEFINED_PORT)
@AutoConfigureWebTestClient
@ExtendWith(JaasExtension.class)
@ContextConfiguration
@EnableTransactionManagement(proxyTargetClass = false)
@SuppressWarnings("checkstyle:LineLength")
class TestLockingAndClustering extends AbsIntegrationTest {

  private static final Logger LOGGER = LoggerFactory.getLogger(TestLockingAndClustering.class);
  private static final String BASIC_OUTBOX_PATH = "http://localhost:10020/outbox-rest/events";

  @LocalServerPort
  private Integer port;
  @Autowired
  private HttpHeaderProvider httpHeaderProvider;
  @Autowired
  TaskanaTaskStarter taskanaTaskStarter;
  @Autowired
  TaskanaTaskTerminator taskanaTaskTerminator;

  @Autowired
  ReferencedTaskClaimer referencedTaskClaimer;

  @Autowired
  ReferencedTaskClaimCanceler referencedTaskClaimCanceler;

  @Autowired
  ReferencedTaskCompleter referencedTaskCompleter;


  @Value("${taskana-system-connector-camundaSystemURLs}")
  private String configuredSystemConnectorUrls;

  @WithAccessId(
      user = "teamlead_1",
      groups = {"taskadmin"})
  @Test
  public void should_lockEventsForTheCorrectTime_When_Getting() {
    TestRestTemplate restTemplate =
        new TestRestTemplate(
            new RestTemplateBuilder()
                .rootUri("http://localhost:" + port)
                .requestFactory(OkHttp3ClientHttpRequestFactory.class));
    this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_user_task_with_complex_variables_process", "");

    String url = BASIC_OUTBOX_PATH + "?lock-for=10";

    HttpEntity<Void> requestEntity = httpHeaderProvider.prepareNewEntityForOutboxRestApi();
    ResponseEntity<CamundaTaskEventListResource> answer =
        restTemplate.exchange(
            url, HttpMethod.GET, requestEntity, CamundaTaskEventListResource.class);

    assertThat(answer.getBody()).isNotNull();
    assertThat(answer.getBody().getCamundaTaskEvents()).isNotEmpty();
    answer =
        restTemplate.exchange(
            url, HttpMethod.GET, requestEntity, CamundaTaskEventListResource.class);

    assertThat(answer.getBody()).isNotNull();
    assertThat(answer.getBody().getCamundaTaskEvents()).isEmpty();

    try {
      Thread.sleep(10000);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    answer =
        restTemplate.exchange(
            url, HttpMethod.GET, requestEntity, CamundaTaskEventListResource.class);

    assertThat(answer.getBody()).isNotNull();
    assertThat(answer.getBody().getCamundaTaskEvents()).isNotEmpty();

  }

  @Test
  public void should_createCorrespondingTaskanaTasksConcurrently() throws Exception {
    this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_user_task_with_complex_variables_process", "");
    List<String> accessIds =
        Collections.synchronizedList(
            Stream.of("admin", "taskadmin")
                .collect(Collectors.toList()));
    PrivilegedAction<Void> action =
        () -> {
          taskanaTaskStarter.retrieveReferencedTasksAndCreateCorrespondingTaskanaTasks();
          return null;
        };
    ParallelThreadHelper.runInThread(
        getRunnableTest(accessIds, action), accessIds.size());
  }

  @Test
  public void should_finishCorrespondingTaskanaTasksConcurrently() throws Exception {
    String processInstanceId = this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_multiple_execution_process", "");
    List<String> camundaTaskIds =
        this.camundaProcessengineRequester.getTaskIdsFromProcessInstanceId(processInstanceId);
    assertThat(camundaTaskIds).hasSize(3);
    Thread.sleep((long) (this.adapterTaskPollingInterval * 1.2));

    for (String camundaTaskId : camundaTaskIds) {
      this.camundaProcessengineRequester.completeTaskWithId(camundaTaskId);
    }
    List<String> accessIds =
        Collections.synchronizedList(
            Stream.of("admin", "taskadmin")
                .collect(Collectors.toList()));
    PrivilegedAction<Void> action =
        () -> {
          taskanaTaskTerminator.retrieveFinishedReferencedTasksAndTerminateCorrespondingTaskanaTasks();
          return null;
        };
    ParallelThreadHelper.runInThread(
        getRunnableTest(accessIds, action), accessIds.size());
  }

  @WithAccessId(
      user = "teamlead_1",
      groups = {"taskadmin"})
  @Test
  public void should_runMultipleCompletesConcurrently() throws Exception {
    String processInstanceId = this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_multiple_execution_process", "");
    List<String> camundaTaskIds =
        this.camundaProcessengineRequester.getTaskIdsFromProcessInstanceId(processInstanceId);
    assertThat(camundaTaskIds).hasSize(3);
    Thread.sleep((long) (this.adapterTaskPollingInterval * 1.2));

    for (String camundaTaskId : camundaTaskIds) {
      List<TaskSummary> taskanaTasks =
          this.taskService.createTaskQuery().externalIdIn(camundaTaskId).list();
      assertThat(taskanaTasks).hasSize(1);
      this.taskService.forceCompleteTask(taskanaTasks.get(0).getId());
    }
    List<String> accessIds =
        Collections.synchronizedList(
            Stream.of("admin", "taskadmin", "user-1-1")
                .collect(Collectors.toList()));
    PrivilegedAction<Void> action =
        () -> {
          referencedTaskCompleter.retrieveFinishedTaskanaTasksAndCompleteCorrespondingReferencedTask();
          return null;
        };
    ParallelThreadHelper.runInThread(
        getRunnableTest(accessIds, action), accessIds.size());
  }

  @WithAccessId(
      user = "taskadmin",
      groups = {"taskadmin"})
  @Test
  public void should_runMultipleClaimsAndCancelClaimsConcurrently() throws Exception {
    String processInstanceId = this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_multiple_user_tasks_with_complex_variables_process", "");
    List<String> camundaTaskIds =
        this.camundaProcessengineRequester.getTaskIdsFromProcessInstanceId(processInstanceId);
    assertThat(camundaTaskIds).hasSize(3);
    Thread.sleep((long) (this.adapterTaskPollingInterval * 3.0));

    for (String camundaTaskId : camundaTaskIds) {
      List<TaskSummary> taskanaTasks =
          this.taskService.createTaskQuery().externalIdIn(camundaTaskId).list();
      assertThat(taskanaTasks).hasSize(1);
      this.taskService.claim(taskanaTasks.get(0).getId());
    }
    List<String> accessIds =
        Collections.synchronizedList(
            Stream.of("taskadmin", "taskadmin", "taskadmin")
                .collect(Collectors.toList()));
    PrivilegedAction<Void> action =
        () -> {
          try {
            referencedTaskClaimer.retrieveClaimedTaskanaTasksAndClaimCorrespondingReferencedTask();
          } catch (Exception e) {
            throw new RuntimeException(e);
          }
          return null;
        };
    ParallelThreadHelper.runInThread(
        getRunnableTest(accessIds, action), accessIds.size());
    for (String camundaTaskId : camundaTaskIds) {
      JSONObject task = this.camundaProcessengineRequester.getTaskAsJsonFromTaskId(camundaTaskId);
      assertThat(task.has("assignee")).isTrue();
      assertThat(task.get("assignee")).isNotNull().isEqualTo("taskadmin");
    }
    for (String camundaTaskId : camundaTaskIds) {
      List<TaskSummary> taskanaTasks =
          this.taskService.createTaskQuery().externalIdIn(camundaTaskId).list();
      assertThat(taskanaTasks).hasSize(1);
      this.taskService.cancelClaim(taskanaTasks.get(0).getId());
    }
    action =
        () -> {
          referencedTaskClaimCanceler.retrieveCancelledClaimTaskanaTasksAndCancelClaimCorrespondingReferencedTask();
          return null;
        };
    List<String> accessIds2 =
        Collections.synchronizedList(
            Stream.of("taskadmin", "taskadmin", "taskadmin")
                .collect(Collectors.toList()));
    ParallelThreadHelper.runInThread(
        getRunnableTest(accessIds2, action), accessIds2.size());
    for (String camundaTaskId : camundaTaskIds) {
      JSONObject task = this.camundaProcessengineRequester.getTaskAsJsonFromTaskId(camundaTaskId);
      assertThat(task.isNull("assignee")).isTrue();
    }
  }

  private Runnable getRunnableTest(List<String> accessIds, PrivilegedAction<Void> action) {
    return () -> {
      Subject subject = new Subject();
      subject.getPrincipals().add(new UserPrincipal(accessIds.remove(0)));
      Subject.doAs(subject, action);
    };
  }

}
